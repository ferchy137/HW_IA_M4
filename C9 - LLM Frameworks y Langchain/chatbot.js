// chatbot.js
import dotenv from "dotenv";
import fetch from "node-fetch";
import readline from "readline";
import { GoogleGenerativeAI } from "@google/generative-ai";
import * as cheerio from "cheerio";
import https from "https";

dotenv.config();

// Inicializa Gemini
const client = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = client.getGenerativeModel({ model: "gemini-1.5-flash" });


const agent = new https.Agent({
  rejectUnauthorized: false, // ignora certificados no v치lidos
});

// Memoria de la conversaci칩n
let conversationHistory = [];

// --- Funci칩n de b칰squeda con SERPER ---
/**
 * The function `googleSearch` performs a POST request to a specified API endpoint to search for news
 * related to the economy and returns the top 5 organic search results as an array of objects with
 * title and link properties.
 * @param query - The `query` parameter in the `googleSearch` function seems to be defined but not used
 * within the function. If you intended to use the `query` parameter to perform the search, you should
 * update the `body` property in the `fetch` call to use the `query` parameter instead
 * @returns The `googleSearch` function returns an array of objects with `title` and `link` properties
 * for the top 5 organic search results related to the query "noticias econom칤a" from the specified API
 * endpoint. If there is an error during the search process, an empty array is returned.
 */
async function googleSearch(query) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 10000); // 10s
  try {
    const res = await fetch("https://google.serper.dev/search", {
      method: "POST",
      headers: {
        "X-API-KEY": process.env.SERPER_API_KEY,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ q: "noticias econom칤a" }),
      agent,
    });
    clearTimeout(timeout);
    const data = await res.json();
    return data.organic?.slice(0, 5).map(r => ({ title: r.title, link: r.link })) || [];
  } catch (err) {
    console.error("Error en googleSearch:", err.message);
    return [];
  }
}

// --- Funci칩n para scrapear CNN Espa침ol y CBC ---
/**
 * The function `scrapeSources` asynchronously scrapes content from specified URLs, extracts the first
 * visible paragraphs, limits the content to 500 characters, and returns an array of objects containing
 * the source URL and extracted content.
 * @returns The `scrapeSources` function is returning an array of objects, where each object represents
 * a source URL along with the extracted content from that URL. The content is limited to the first 500
 * characters of visible text extracted from the `<p>` elements of the HTML of each URL.
 */
async function scrapeSources() {
  const urls = [
    "https://cnnespanol.cnn.com/lite/",
    "https://www.cbc.ca/lite/news?sort=latest"
  ];

  const docs = [];

  for (const url of urls) {
    try {
      const res = await fetch(url);
      const html = await res.text();
      const $ = cheerio.load(html);
      // extraer solo los primeros p치rrafos visibles
      const text = $("p").map((i, el) => $(el).text()).get().join("\n");
      docs.push({ source: url, content: text.slice(0, 500) }); // limitamos a 500 caracteres
    } catch (err) {
      console.error(`Error al obtener ${url}:`, err.message);
    }
  }

  return docs;
}

// --- Funci칩n para responder en streaming ---
/**
 * The function `generateStreamingResponse` processes a conversation history and a prompt to generate a
 * streaming response using a model.
 * @param prompt - The `generateStreamingResponse` function you provided seems to be a part of a
 * chatbot or conversational AI system. It takes a prompt as input and generates a streaming response
 * based on the conversation history and the prompt.
 * @returns The `generateStreamingResponse` function returns the full response generated by the model
 * based on the conversation history and the user prompt.
 */
async function generateStreamingResponse(prompt) {
  const chatHistory = conversationHistory.map(c => `${c.role}: ${c.content}`).join("\n");

  const stream = await model.generateContentStream({
    contents: [{ role: "user", parts: [{ text: chatHistory + "\nUsuario: " + prompt }] }],
  });

  let fullResponse = "";
  for await (const chunk of stream.stream) {
    if (chunk.candidates && chunk.candidates.length > 0) {
      const text = chunk.candidates[0].content.parts[0]?.text || "";
      process.stdout.write(text); // imprime en tiempo real
      fullResponse += text;
    }
  }

  console.log("\n");
  return fullResponse;
}

// --- Interfaz de consola ---
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

/**
 * The function `main` implements a chatbot with memory, search capabilities, and streaming responses,
 * allowing users to interact and receive information from the web and news sources.
 */
async function main() {
  console.log("游뱄 Chatbot con memoria, b칰squeda y streaming. Escribe 'salir' para terminar.\n");

  while (true) {
    const input = await new Promise(resolve => rl.question(">> ", resolve));
    if (input.toLowerCase() === "salir") {
      console.log("游녦 춰Hasta luego!");
      rl.close();
      break;
    }

    // Guardar en memoria
    conversationHistory.push({ role: "user", content: input });

    // B칰squeda en Internet
    console.log("游댍 Buscando informaci칩n en la web...");
    const results = await googleSearch(input);

    // Scraping de CNN y CBC
    const newsDocs = await scrapeSources();

    // Preparar contexto para el modelo
    const context = `
Usuario pregunt칩: ${input}

Fuentes de Google:
${results.map(r => `${r.title} (${r.link})`).join("\n")}

칔ltimas noticias CNN/CBC:
${newsDocs.map(d => `${d.source}: ${d.content}`).join("\n")}
    `;

    console.log("游눫 Respuesta en streaming:\n");
    const response = await generateStreamingResponse(context);

    // Guardar en memoria
    conversationHistory.push({ role: "assistant", content: response });

    // Citar fuentes
    console.log("\n游닄 Fuentes consultadas:");
    results.forEach(r => console.log("- " + r.link));
    newsDocs.forEach(d => console.log("- " + d.source));
  }
}

main();
